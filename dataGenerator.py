from keras.preprocessing.image import ImageDataGenerator
import numpy as np
import scipy.misc
from PIL import Image
import imageio
import os
import sys
import re
import glob
from utils import *

def resample_small_size(array, input_shape=(1440, 1920),magnify=40):
    '''This function: array in shape (1440, 1920) into 240x240'''
    
    if array.ndim == 3:
        (h, w, c) = array.shape
        mask = False
    else:
        (h,w) = array.shape
        mask = True # if this is mask array input here, we need to use one-hot encoding
        
    ''' split by 480 and resize to 240'''
    if (magnify == 40):
        s = 480
        num_h = int(h/s)
        num_w = int(w/s)
        n = int(num_h*num_w)
        # loop to add each array to output array: out_array (list)  
        out_array = [] 
        for i in range(num_h):
            for j in range(num_w):
                 #select the specific part as the array to preprocess
                if mask:
                    im = array[i*s:(i+1)*s,j*s:(j+1)*s]
                    resize_arr = scipy.misc.imresize(im, (240,240),interp='nearest')
                    resize_arr = np.eye(2)[resize_arr]
                else:
                    im = array[i*s:(i+1)*s,j*s:(j+1)*s,:]
                    resize_arr = scipy.misc.imresize(im, (240,240),interp='bilinear')
                out_array.append(resize_arr)
    
    #if magnify is 20, split by 240, no need to resize
    else:
        if mask:
            array = np.eye(2)[array]
        s = 240
        num_h = int(h/s)
        num_w = int(w/s)
        n = int(num_h*num_w)
        # loop to add each array to output array: out_array (list)  
        out_array = []
        for i in range(num_h):
            for j in range(num_w):
                im = array[i*s:(i+1)*s,j*s:(j+1)*s,:] #select the specific part as the array to preprocess                   
                out_array.append(im)
                
    return out_array

    
def load_data(frame_path, mask_path, w, h):
    #training set
    train_x, train_y = xy_array(mask_path, frame_path, 'train', w, h)
    val_x, val_y = xy_array(mask_path, frame_path, 'val', w, h)
#     test_x, test_y = xy_array(mask_path, frame_path, 'test')
    return train_x, train_y, val_x, val_y

def xy_array(mask_path, frame_path, split, w, h, cl=2):
# use this to load all data if split = ''
    
    mask_path = os.path.join(mask_path, split)
    frame_path = os.path.join(frame_path, split)
    
    frame_files = os.listdir(frame_path)
    num_files = len(frame_files)
    # binary encode   
    x = []
    y = []
    
    for i in range(num_files):
        img = np.array(Image.open(os.path.join(frame_path, frame_files[i]))) # rescale to from 0-1
        # 255 to 1
        mask_name = frame_files[i].replace('RGB','label')
        mask = np.array(Image.open(os.path.join(mask_path, mask_name)))/255
        mask = mask.astype(np.uint8)
        
#         if '20min' in frame_files[i]:
        x += resample_small_size(img, input_shape=(h,w), magnify=40)
        y += resample_small_size(mask, input_shape=(h,w),magnify=40)
#         else:
#             x += resample_small_size(img, input_shape=(h,w), magnify=40)
#             y += resample_small_size(mask, input_shape=(h,w),magnify=40)
        
    return np.array(x),np.array(y)


def random_crop(img, random_crop_size):
    # Note: image_data_format is 'channel_last'
    assert img.shape[2] == 3
    height, width = img.shape[0], img.shape[1]
    dy, dx = random_crop_size
    x = np.random.randint(0, width - dx + 1)
    y = np.random.randint(0, height - dy + 1)
    return img[y:(y+dy), x:(x+dx), :]

def crop_generator(batches, crop_length): # change to enable x and y together
    """Take as input a Keras ImageGen (Iterator) and generate random
    crops from the image batches generated by the original iterator.
    """
    while True:
        batch_x, batch_y = next(batches)
        batch_crops = np.zeros((batch_x.shape[0], crop_length, crop_length, 3))
        for i in range(batch_x.shape[0]):
            batch_crops[i] = random_crop(batch_x[i], (crop_length, crop_length))
        yield (batch_crops, batch_y)         

def trainGen(train_x, train_y, batch_size):
    '''
    can generate image and mask at the same time
    use the same seed for image_datagen and mask_datagen to ensure the transformation for image and mask is the same
    if you want to visualize the results of generator, set save_to_dir = "your path"
    '''
    #has rescaled when loading the data
    x_gen_args = dict(
                    rescale = 1./255,
                    rotation_range=0.2,
                    width_shift_range=0.05,
                    height_shift_range=0.05,
                    shear_range=0.05,
                    zoom_range=0.05,
                    horizontal_flip=True,
                    fill_mode='wrap')
    
    y_gen_args = dict(
                    rotation_range=0.2,
                    width_shift_range=0.05,
                    height_shift_range=0.05,
                    shear_range=0.05,
                    zoom_range=0.05,
                    horizontal_flip=True,
                    fill_mode='wrap')
    
    img_datagen = ImageDataGenerator(**x_gen_args)
    mask_datagen = ImageDataGenerator(**y_gen_args)
    
    img_datagen.fit(train_x)
    mask_datagen.fit(train_y)

    seed = 2018
    img_gen = img_datagen.flow(train_x, seed = seed, batch_size=batch_size, shuffle=True)#shuffling
    mask_gen = mask_datagen.flow(train_y, seed = seed, batch_size=batch_size, shuffle=True)
    
    train_gen = zip(img_gen, mask_gen)
#    train_crops = crop_generator(train_gen, 224)

    return train_gen


def testGen(val_x, val_y, batch_size):
# val_gen
    img_datagen = ImageDataGenerator()
    mask_datagen = ImageDataGenerator()
    
    img_datagen.fit(val_x)
    mask_datagen.fit(val_y)
    
    img_gen = img_datagen.flow(val_x, batch_size=batch_size, shuffle=True)
    mask_gen = mask_datagen.flow(val_y, batch_size=batch_size, shuffle=True)
    val_gen = zip(img_gen, mask_gen)    
        
    return val_gen


def save_results(result_dir, test_x, test_y, predict_y, split='test'):
    
    test_y = np.argmax(test_y, axis=-1).astype(np.uint8)
    predict_y = np.argmax(predict_y, axis=-1).astype(np.uint8)
    
    for i in range(len(test_x)):
        # 256,256,1 -- id --> change to color
        gt = test_y[i].astype('uint8')
        pred = predict_y[i].astype('uint8')
        imageio.imwrite(os.path.join(result_dir, str(i) + '_gt.png'), gt*255)
        imageio.imwrite(os.path.join(result_dir, str(i) + '_pred.png'), pred*255)
