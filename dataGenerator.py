from keras.preprocessing.image import ImageDataGenerator
import numpy as np
import scipy.misc
from PIL import Image
import imageio
import os
import sys
import re
import glob
from utils import *

def resample_small_size(array, input_shape=(1440, 1920),magnify=40):
    '''This function: array in shape (1440, 1920) into 240x240'''
    if array.ndim == 3 and array.shape[2]==3:
        (h, w, c) = array.shape
        mask = False
    else:
        (h,w,c) = array.shape
        mask = True # if this is mask array input here, we need to use one-hot encoding
        
    ''' split by 480 and resize to 240'''
    if (magnify == 40):
        s = 480
        num_h = int(h/s)
        num_w = int(w/s)
        n = int(num_h*num_w)
        # loop to add each array to output array: out_array (list)  
        out_array = [] 
        for i in range(num_h):
            for j in range(num_w):
                 #select the specific part as the array to preprocess
                if mask:
                    im = array[i*s:(i+1)*s,j*s:(j+1)*s,:]
#                     resize_arr = scipy.misc.imresize(im, (240,240),interp='nearest')
#                     resize_arr = np.eye(2)[resize_arr]
                else:
                    im = array[i*s:(i+1)*s,j*s:(j+1)*s,:]
#                     resize_arr = scipy.misc.imresize(im, (240,240),interp='bilinear')
                out_array.append(im)
    
    #if magnify is 20, split by 240, no need to resize
    else:
        if mask:
            array = np.eye(2)[array]
        s = 240
        num_h = int(h/s)
        num_w = int(w/s)
        n = int(num_h*num_w)
        # loop to add each array to output array: out_array (list)  
        out_array = []
        for i in range(num_h):
            for j in range(num_w):
                im = array[i*s:(i+1)*s,j*s:(j+1)*s,:] #select the specific part as the array to preprocess                   
                out_array.append(im)
                
    return out_array

    
def load_data(frame_path, mask_path, w, h):
    #training set
    train_x, train_y = xy_array(mask_path, frame_path, 'train', w, h)
    val_x, val_y = xy_array(mask_path, frame_path, 'val', w, h)
#     test_x, test_y = xy_array(mask_path, frame_path, 'test')
    return train_x, train_y, val_x, val_y

def xy_array(mask_path, frame_path, split, w, h, cl=2):
# use this to load all data if split = ''
    ''' return a x, y array with original shape'''
    
    mask_path = os.path.join(mask_path, split)
    frame_path = os.path.join(frame_path, split)
    
    frame_files = os.listdir(frame_path)
    num_files = len(frame_files)
    # binary encode   
    x = []
    y = []
    
    for i in range(num_files):
        img = np.array(Image.open(os.path.join(frame_path, frame_files[i])))
        mask_name = frame_files[i].replace('RGB','label')
        mask = np.array(Image.open(os.path.join(mask_path, mask_name)))/255
        mask = mask.astype(np.uint8)
        mask = np.eye(2)[mask]
        x.append(img)
        y.append(mask)
    return np.array(x),np.array(y)

def resize_val(x, y, shape=224):
    n = x.shape[0]
    ret_x = []
    ret_y = []
    for i in range(n):
        im = scipy.misc.imresize(x[i], (shape,shape),interp='nearest')
        ret_x.append(im)
        mask = np.array(Image.fromarray(y[i,:,:,1]).resize((shape,shape), Image.NEAREST)).astype('uint8')
        ret_y.append(np.eye(2)[mask])
    return np.array(ret_x), np.array(ret_y)

def center_crop(img, mask, random_crop_size):
    height, width = img.shape[0], img.shape[1]
    dy, dx = random_crop_size
    y = (height - dy)//2
    x = (width - dx)//2
    return img[y:(y+dy), x:(x+dx), :], mask[y:(y+dy), x:(x+dx), :]

def random_crop(img, mask, random_crop_size):
    # Note: image_data_format is 'channel_last'
    # assert img.shape[2] == 3
    height, width = img.shape[0], img.shape[1]
    dy, dx = random_crop_size
    x = np.random.randint(0, width - dx + 1)
    y = np.random.randint(0, height - dy + 1)
    return img[y:(y+dy), x:(x+dx), :], mask[y:(y+dy), x:(x+dx), :]

def crop_generator(batches, crop_length, random=True): # change to enable x and y together
    """Take as input a Keras ImageGen (Iterator) and generate random
    crops from the image batches generated by the original iterator.
    """
    while True:
        batch_x, batch_y = next(batches)
        batch_crop_x = np.zeros((batch_x.shape[0], crop_length, crop_length, 3))
        batch_crop_y = np.zeros((batch_y.shape[0], crop_length, crop_length, 2))
        for i in range(batch_x.shape[0]):
            if random:
                batch_crop_x[i], batch_crop_y[i] = random_crop(batch_x[i], batch_y[i], (crop_length, crop_length))
            else:
                batch_crop_x[i], batch_crop_y[i] = center_crop(batch_x[i], batch_y[i], (crop_length, crop_length))
        yield (batch_crop_x, batch_crop_y)     

def trainGen(train_x, train_y, batch_size):
    '''
    can generate image and mask at the same time
    use the same seed for image_datagen and mask_datagen to ensure the transformation for image and mask is the same
    if you want to visualize the results of generator, set save_to_dir = "your path"
    '''
    #has rescaled when loading the data
    x_gen_args = dict(
                    rescale = 1./255,
                    rotation_range=0.2,
                    width_shift_range=0.05,
                    height_shift_range=0.05,
                    shear_range=0.05,
                    zoom_range=0.05,
                    horizontal_flip=True,
                    fill_mode='wrap')
    
    y_gen_args = dict(
                    rotation_range=0.2,
                    width_shift_range=0.05,
                    height_shift_range=0.05,
                    shear_range=0.05,
                    zoom_range=0.05,
                    horizontal_flip=True,
                    fill_mode='wrap')
    
    img_datagen = ImageDataGenerator(**x_gen_args)
    mask_datagen = ImageDataGenerator(**y_gen_args)
    seed = 2018    
    img_datagen.fit(train_x,augment=True,seed=seed)
    mask_datagen.fit(train_y,augment=True,seed=seed)

    img_gen = img_datagen.flow(train_x, seed = seed, batch_size=batch_size, shuffle=True)#shuffling
    mask_gen = mask_datagen.flow(train_y, seed = seed, batch_size=batch_size, shuffle=True)
    
    train_gen = zip(img_gen, mask_gen)
    train_crops = crop_generator(train_gen, 480, random=True)

    return train_crops


def testGen(val_x, val_y, batch_size):
# val_gen
    img_datagen = ImageDataGenerator(rescale = 1./255)
    mask_datagen = ImageDataGenerator()
    
    img_datagen.fit(val_x)
    mask_datagen.fit(val_y)
    
    seed = 20
    img_gen = img_datagen.flow(val_x, seed=seed, batch_size=batch_size, shuffle=False)
    mask_gen = mask_datagen.flow(val_y, seed=seed, batch_size=batch_size, shuffle=False)
    val_gen = zip(img_gen, mask_gen)    
    val_crops = crop_generator(val_gen, 480, random=False)    
    return val_crops


def save_results(result_dir, test_x, test_y, predict_y, split='test'):
    
    test_y = np.argmax(test_y, axis=-1).astype(np.uint8)
    predict_y = np.argmax(predict_y, axis=-1).astype(np.uint8)
    
    for i in range(len(test_x)):
        # 256,256,1 -- id --> change to color
        gt = test_y[i].astype('uint8')
        pred = predict_y[i].astype('uint8')
        x = test_x[i]
        imageio.imwrite(os.path.join(result_dir, str(i) + '_input.png'), x*255)
        imageio.imwrite(os.path.join(result_dir, str(i) + '_gt.png'), gt*255)
        imageio.imwrite(os.path.join(result_dir, str(i) + '_pred.png'), pred*255)
